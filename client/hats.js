// ==UserScript==
// @name         mpp-hats
// @namespace    http://github.com/Hri7566/hats
// @version      2.1.1
// @description  Hats for MPP.net
// @author       Hri7566
// @match        https://www.multiplayerpiano.net/*
// @match        https://*.multiplayerpiano.net/*
// @match        https://*.multiplayerpiano.org/*
// @match        https://mpp.8448.space/*
// @grant        GM_getResourceText
// @grant        GM_addStyle
// ==/UserScript==
// Build date: 2024-05-08T19:04:24.300Z
var B2 = Object.defineProperty; var z2 = (Q, W) => { for (var X in W) B2(Q, X, { get: W[X], enumerable: !0, configurable: !0, set: (G) => W[X] = () => G }) }; var x0 = {}; z2(x0, { uncachePartHat: () => { { return g0 } }, setPartHat: () => { { return B0 } }, serverAddress: () => { { return i } }, removeHat: () => { { return d0 } }, hatCache: () => { { return d } }, getPartHat: () => { { return z0 } }, getHatList: () => { { return T0 } }, getHatImage: () => { { return _2 } }, getHatBaseURL: () => { { return r } }, getCurrentHat: () => { { return v } }, changeHat: () => { { return F0 } }, applyHat: () => { { return E0 } } }); function p(Q, W) { MPP.client.sendArray([{ m: "custom", target: { mode: "id", id: Q }, data: W }]) } function v() { return I0 } function r(Q) { return new URL(i + `/hat?id=${Q}`) } async function _2(Q) { return new URL(i + `/hat?id=${Q}`) } function d0(Q) { const W = Object.values(MPP.client.ppl).find((X) => X._id == Q); if (!W) return; $(W.nameDiv).children(".mpp-hat").remove(), $(W.cursorDiv).children(".name").children(".cursor-hat-conatiner").remove() } async function E0(Q, W) { if (typeof MPP.client.channel == "undefined") return; const X = Object.values(MPP.client.ppl).find((A) => A._id == Q); if (!X) return; $(X.nameDiv).prepend(`<div class="mpp-hat" data-hat-id="${W}"></div>`); const G = $(X.cursorDiv).children(".name"); let J = "", q = "", Y = $(X.cursorDiv).text(); if ($(G).children(".nametext").text().length !== 0) J = $(G).children(".curtag").text(), q = $(G).children(".curtag").css("background-color"), Y = $(G).children(".nametext").text(); if ($(X.cursorDiv).children(".name").html(`<span class="nametext">${Y}</span><div class="cursor-hat-container"><div class="cursor-hat"></div></div>`), J.length !== 0) $(X.cursorDiv).children(".name").prepend(`<span class="curtag" id="nametag-${X._id}" style="background-color: ${q};">${J}</span>`); $(X.cursorDiv).children(".name").css({ display: "block", "align-items": "center", position: "relative", "white-space": "nowrap", height: "fit-content", width: "fit-content", "line-height": "15px", "text-align": "center", "border-radius": "3px", left: "18px", top: "12px", "pointer-events": "none", color: "#fff", padding: "unset", "font-size": "unset" }), $(X.cursorDiv).children(".name").children("span.nametext").css({ display: "inline-block", "pointer-events": "none", color: "#fff", "border-radius": "2px", "margin-bottom": "1px", "white-space": "nowrap", "flex-shrink": "0", "font-size": "10px" }); const M = $(X.nameDiv).children(".mpp-hat"), w = $(X.cursorDiv).children(".name").children(".cursor-hat-container"), R = $(X.cursorDiv).children(".name").children(".cursor-hat-container").children(".cursor-hat"); if (M.css({ background: `url(${i}/hat?id=${encodeURIComponent(W)})`, width: "16px", height: "16px", position: "absolute", top: "-8px", left: "4px" }), w.css({ display: "inline-block", position: "relative", top: "-24px", right: "0", height: "0", width: "16px" }), R.css({ content: `url(${i}/hat?id=${encodeURIComponent(W)})` }), typeof MPP.client.channel.crown == "object") { if (MPP.client.channel.crown.hasOwnProperty("userId")) { if (MPP.client.channel.crown.userId == Q) M.css({ top: "-8px", left: "20px" }), w.css({ position: "absolute", top: "-6px", right: "17px" }) } } } async function B0(Q, W) { d0(Q), await E0(Q, W), d.set(Q, W); let X = {}; for (let [G, J] of d.entries()) X[G] = J; localStorage.setItem("hatCache", JSON.stringify(X)) } function z0(Q) { const W = d.get(Q); if (typeof W !== "undefined") return W; p(Q, { m: "hat_query" }) } async function g0(Q) { d.delete(Q) } async function F0(Q) { I0 = Q, localStorage.setItem("hat", v()), B0(MPP.client.getOwnParticipant()._id, Q), MPP.client.sendArray([{ m: "custom", target: { mode: "subscribed" }, data: { m: "hat_change", hat: v() } }]); try { $("#mpp-hats-button-icon").attr("src", r(v()).toString()) } catch (W) { } } async function T0() { return await (await fetch(i + "/list")).json() } var i = "https://hats.hri7566.info/api", I0 = "tophat", h0 = localStorage.getItem("hat"), P0 = localStorage.getItem("hatCache"); if (typeof h0 !== "undefined" && h0 !== null) I0 = h0; var d = new Map; if (typeof P0 !== "undefined" && P0 !== null) { const Q = JSON.parse(P0); for (let W of Object.keys(Q)) d.set(W, Q[W]) } class l0 { _events = {}; on(Q, W) { if (typeof this._events[Q] == "undefined") this._events[Q] = []; const X = { once: !1, listener: W }; this._events[Q].push(X) } off(Q, W) { if (typeof this._events[Q] == "undefined") return; for (let X in this._events[Q]) { if (typeof X !== "number") continue; if (!(X in this._events[Q][X])) continue; if (this._events[Q][X].listener !== W) continue; this._events[Q].splice(X, 1) } } once(Q, W) { if (typeof this._events[Q] == "undefined") return; this._events[Q].push({ once: !0, listener: W }) } emit(Q, W) { const X = Q.evtn; if (!X) return; if (typeof this._events[X] == "undefined") return; for (let G in this._events[Q.evtn]) { if (isNaN(parseInt(G))) continue; if (typeof this._events[X][G] == "undefined") continue; const J = this._events[X][G]; if (!J) continue; if (J.once) this._events[X].splice(parseInt(G), 1); J.listener(Q, W) } } } var o = new l0; globalThis.e = o; o.on("query", (Q, W) => { const X = W.p; p(X, { m: "hat_query_reply", hat: v() }) }); o.on("query_reply", async (Q, W) => { await B0(W.p, Q.hat) }); o.on("change", async (Q, W) => { await B0(W.p, Q.hat) }); var R2 = function (Q) { a0 = Q }, K0 = function () { return a0 }, B = function (Q, W) { const X = K0(), G = N0({ issueData: W, data: Q.data, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, X, X === e ? void 0 : e].filter((J) => !!J) }); Q.common.issues.push(G) }, b0 = function (Q, W, X, G) { if (X === "a" && !G) throw new TypeError("Private accessor was defined without a getter"); if (typeof W === "function" ? Q !== W || !G : !W.has(Q)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return X === "m" ? G : X === "a" ? G.call(Q) : G ? G.value : W.get(Q) }, t0 = function (Q, W, X, G, J) { if (G === "m") throw new TypeError("Private method is not writable"); if (G === "a" && !J) throw new TypeError("Private accessor was defined without a setter"); if (typeof W === "function" ? Q !== W || !J : !W.has(Q)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return G === "a" ? J.call(Q, X) : J ? J.value = X : W.set(Q, X), X }, V = function (Q) { if (!Q) return {}; const { errorMap: W, invalid_type_error: X, required_error: G, description: J } = Q; if (W && (X || G)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`); if (W) return { errorMap: W, description: J }; return { errorMap: (Y, M) => { var w, R; const { message: A } = Q; if (Y.code === "invalid_enum_value") return { message: A !== null && A !== void 0 ? A : M.defaultError }; if (typeof M.data === "undefined") return { message: (w = A !== null && A !== void 0 ? A : G) !== null && w !== void 0 ? w : M.defaultError }; if (Y.code !== "invalid_type") return { message: M.defaultError }; return { message: (R = A !== null && A !== void 0 ? A : X) !== null && R !== void 0 ? R : M.defaultError } }, description: J } }, e0 = function (Q) { let W = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"; if (Q.precision) W = `${W}\\.\\d{${Q.precision}}`; else if (Q.precision == null) W = `${W}(\\.\\d+)?`; return W }, C2 = function (Q) { return new RegExp(`^${e0(Q)}\$`) }, $2 = function (Q) { let W = `${s0}T${e0(Q)}`; const X = []; if (X.push(Q.local ? "Z?" : "Z"), Q.offset) X.push("([+-]\\d{2}:?\\d{2})"); return W = `${W}(${X.join("|")})`, new RegExp(`^${W}\$`) }, v2 = function (Q, W) { if ((W === "v4" || !W) && K2.test(Q)) return !0; if ((W === "v6" || !W) && N2.test(Q)) return !0; return !1 }, k2 = function (Q, W) { const X = (Q.toString().split(".")[1] || "").length, G = (W.toString().split(".")[1] || "").length, J = X > G ? X : G, q = parseInt(Q.toFixed(J).replace(".", "")), Y = parseInt(W.toFixed(J).replace(".", "")); return q % Y / Math.pow(10, J) }, a = function (Q) { if (Q instanceof U) { const W = {}; for (let X in Q.shape) { const G = Q.shape[X]; W[X] = f.create(a(G)) } return new U({ ...Q._def, shape: () => W }) } else if (Q instanceof b) return new b({ ...Q._def, type: a(Q.element) }); else if (Q instanceof f) return f.create(a(Q.unwrap())); else if (Q instanceof I) return I.create(a(Q.unwrap())); else if (Q instanceof h) return h.create(Q.items.map((W) => a(W))); else return Q }, u0 = function (Q, W) { const X = T(Q), G = T(W); if (Q === W) return { valid: !0, data: Q }; else if (X === z.object && G === z.object) { const J = L.objectKeys(W), q = L.objectKeys(Q).filter((M) => J.indexOf(M) !== -1), Y = { ...Q, ...W }; for (let M of q) { const w = u0(Q[M], W[M]); if (!w.valid) return { valid: !1 }; Y[M] = w.data } return { valid: !0, data: Y } } else if (X === z.array && G === z.array) { if (Q.length !== W.length) return { valid: !1 }; const J = []; for (let q = 0; q < Q.length; q++) { const Y = Q[q], M = W[q], w = u0(Y, M); if (!w.valid) return { valid: !1 }; J.push(w.data) } return { valid: !0, data: J } } else if (X === z.date && G === z.date && +Q === +W) return { valid: !0, data: Q }; else return { valid: !1 } }, Q2 = function (Q, W) { return new m({ values: Q, typeName: O.ZodEnum, ...V(W) }) }, W2 = function (Q, W = {}, X) { if (Q) return c.create().superRefine((G, J) => { var q, Y; if (!Q(G)) { const M = typeof W === "function" ? W(G) : typeof W === "string" ? { message: W } : W, w = (Y = (q = M.fatal) !== null && q !== void 0 ? q : X) !== null && Y !== void 0 ? Y : !0, R = typeof M === "string" ? { message: M } : M; J.addIssue({ code: "custom", ...R, fatal: w }) } }); return c.create() }, L; (function (Q) { Q.assertEqual = (J) => J; function W(J) { } Q.assertIs = W; function X(J) { throw new Error } Q.assertNever = X, Q.arrayToEnum = (J) => { const q = {}; for (let Y of J) q[Y] = Y; return q }, Q.getValidEnumValues = (J) => { const q = Q.objectKeys(J).filter((M) => typeof J[J[M]] !== "number"), Y = {}; for (let M of q) Y[M] = J[M]; return Q.objectValues(Y) }, Q.objectValues = (J) => { return Q.objectKeys(J).map(function (q) { return J[q] }) }, Q.objectKeys = typeof Object.keys === "function" ? (J) => Object.keys(J) : (J) => { const q = []; for (let Y in J) if (Object.prototype.hasOwnProperty.call(J, Y)) q.push(Y); return q }, Q.find = (J, q) => { for (let Y of J) if (q(Y)) return Y; return }, Q.isInteger = typeof Number.isInteger === "function" ? (J) => Number.isInteger(J) : (J) => typeof J === "number" && isFinite(J) && Math.floor(J) === J; function G(J, q = " | ") { return J.map((Y) => typeof Y === "string" ? `'${Y}'` : Y).join(q) } Q.joinValues = G, Q.jsonStringifyReplacer = (J, q) => { if (typeof q === "bigint") return q.toString(); return q } })(L || (L = {})); var m0; (function (Q) { Q.mergeShapes = (W, X) => { return { ...W, ...X } } })(m0 || (m0 = {})); var z = L.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), T = (Q) => { switch (typeof Q) { case "undefined": return z.undefined; case "string": return z.string; case "number": return isNaN(Q) ? z.nan : z.number; case "boolean": return z.boolean; case "function": return z.function; case "bigint": return z.bigint; case "symbol": return z.symbol; case "object": if (Array.isArray(Q)) return z.array; if (Q === null) return z.null; if (Q.then && typeof Q.then === "function" && Q.catch && typeof Q.catch === "function") return z.promise; if (typeof Map !== "undefined" && Q instanceof Map) return z.map; if (typeof Set !== "undefined" && Q instanceof Set) return z.set; if (typeof Date !== "undefined" && Q instanceof Date) return z.date; return z.object; default: return z.unknown } }, H = L.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), O2 = (Q) => { return JSON.stringify(Q, null, 2).replace(/"([^"]+)":/g, "$1:") }; class F extends Error { constructor(Q) { super(); this.issues = [], this.addIssue = (X) => { this.issues = [...this.issues, X] }, this.addIssues = (X = []) => { this.issues = [...this.issues, ...X] }; const W = new.target.prototype; if (Object.setPrototypeOf) Object.setPrototypeOf(this, W); else this.__proto__ = W; this.name = "ZodError", this.issues = Q } get errors() { return this.issues } format(Q) { const W = Q || function (J) { return J.message }, X = { _errors: [] }, G = (J) => { for (let q of J.issues) if (q.code === "invalid_union") q.unionErrors.map(G); else if (q.code === "invalid_return_type") G(q.returnTypeError); else if (q.code === "invalid_arguments") G(q.argumentsError); else if (q.path.length === 0) X._errors.push(W(q)); else { let Y = X, M = 0; while (M < q.path.length) { const w = q.path[M]; if (M !== q.path.length - 1) Y[w] = Y[w] || { _errors: [] }; else Y[w] = Y[w] || { _errors: [] }, Y[w]._errors.push(W(q)); Y = Y[w], M++ } } }; return G(this), X } static assert(Q) { if (!(Q instanceof F)) throw new Error(`Not a ZodError: ${Q}`) } toString() { return this.message } get message() { return JSON.stringify(this.issues, L.jsonStringifyReplacer, 2) } get isEmpty() { return this.issues.length === 0 } flatten(Q = (W) => W.message) { const W = {}, X = []; for (let G of this.issues) if (G.path.length > 0) W[G.path[0]] = W[G.path[0]] || [], W[G.path[0]].push(Q(G)); else X.push(Q(G)); return { formErrors: X, fieldErrors: W } } get formErrors() { return this.flatten() } } F.create = (Q) => { return new F(Q) }; var e = (Q, W) => { let X; switch (Q.code) { case H.invalid_type: if (Q.received === z.undefined) X = "Required"; else X = `Expected ${Q.expected}, received ${Q.received}`; break; case H.invalid_literal: X = `Invalid literal value, expected ${JSON.stringify(Q.expected, L.jsonStringifyReplacer)}`; break; case H.unrecognized_keys: X = `Unrecognized key(s) in object: ${L.joinValues(Q.keys, ", ")}`; break; case H.invalid_union: X = "Invalid input"; break; case H.invalid_union_discriminator: X = `Invalid discriminator value. Expected ${L.joinValues(Q.options)}`; break; case H.invalid_enum_value: X = `Invalid enum value. Expected ${L.joinValues(Q.options)}, received '${Q.received}'`; break; case H.invalid_arguments: X = "Invalid function arguments"; break; case H.invalid_return_type: X = "Invalid function return type"; break; case H.invalid_date: X = "Invalid date"; break; case H.invalid_string: if (typeof Q.validation === "object") if ("includes" in Q.validation) { if (X = `Invalid input: must include "${Q.validation.includes}"`, typeof Q.validation.position === "number") X = `${X} at one or more positions greater than or equal to ${Q.validation.position}` } else if ("startsWith" in Q.validation) X = `Invalid input: must start with "${Q.validation.startsWith}"`; else if ("endsWith" in Q.validation) X = `Invalid input: must end with "${Q.validation.endsWith}"`; else L.assertNever(Q.validation); else if (Q.validation !== "regex") X = `Invalid ${Q.validation}`; else X = "Invalid"; break; case H.too_small: if (Q.type === "array") X = `Array must contain ${Q.exact ? "exactly" : Q.inclusive ? "at least" : "more than"} ${Q.minimum} element(s)`; else if (Q.type === "string") X = `String must contain ${Q.exact ? "exactly" : Q.inclusive ? "at least" : "over"} ${Q.minimum} character(s)`; else if (Q.type === "number") X = `Number must be ${Q.exact ? "exactly equal to " : Q.inclusive ? "greater than or equal to " : "greater than "}${Q.minimum}`; else if (Q.type === "date") X = `Date must be ${Q.exact ? "exactly equal to " : Q.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(Q.minimum))}`; else X = "Invalid input"; break; case H.too_big: if (Q.type === "array") X = `Array must contain ${Q.exact ? "exactly" : Q.inclusive ? "at most" : "less than"} ${Q.maximum} element(s)`; else if (Q.type === "string") X = `String must contain ${Q.exact ? "exactly" : Q.inclusive ? "at most" : "under"} ${Q.maximum} character(s)`; else if (Q.type === "number") X = `Number must be ${Q.exact ? "exactly" : Q.inclusive ? "less than or equal to" : "less than"} ${Q.maximum}`; else if (Q.type === "bigint") X = `BigInt must be ${Q.exact ? "exactly" : Q.inclusive ? "less than or equal to" : "less than"} ${Q.maximum}`; else if (Q.type === "date") X = `Date must be ${Q.exact ? "exactly" : Q.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(Q.maximum))}`; else X = "Invalid input"; break; case H.custom: X = "Invalid input"; break; case H.invalid_intersection_types: X = "Intersection results could not be merged"; break; case H.not_multiple_of: X = `Number must be a multiple of ${Q.multipleOf}`; break; case H.not_finite: X = "Number must be finite"; break; default: X = W.defaultError, L.assertNever(Q) }return { message: X } }, a0 = e, N0 = (Q) => { const { data: W, path: X, errorMaps: G, issueData: J } = Q, q = [...X, ...J.path || []], Y = { ...J, path: q }; if (J.message !== void 0) return { ...J, path: q, message: J.message }; let M = ""; const w = G.filter((R) => !!R).slice().reverse(); for (let R of w) M = R(Y, { data: W, defaultError: M }).message; return { ...J, path: q, message: M } }, j2 = []; class D { constructor() { this.value = "valid" } dirty() { if (this.value === "valid") this.value = "dirty" } abort() { if (this.value !== "aborted") this.value = "aborted" } static mergeArray(Q, W) { const X = []; for (let G of W) { if (G.status === "aborted") return j; if (G.status === "dirty") Q.dirty(); X.push(G.value) } return { status: Q.value, value: X } } static async mergeObjectAsync(Q, W) { const X = []; for (let G of W) { const J = await G.key, q = await G.value; X.push({ key: J, value: q }) } return D.mergeObjectSync(Q, X) } static mergeObjectSync(Q, W) { const X = {}; for (let G of W) { const { key: J, value: q } = G; if (J.status === "aborted") return j; if (q.status === "aborted") return j; if (J.status === "dirty") Q.dirty(); if (q.status === "dirty") Q.dirty(); if (J.value !== "__proto__" && (typeof q.value !== "undefined" || G.alwaysSet)) X[J.value] = q.value } return { status: Q.value, value: X } } } var j = Object.freeze({ status: "aborted" }), t = (Q) => ({ status: "dirty", value: Q }), E = (Q) => ({ status: "valid", value: Q }), Z0 = (Q) => Q.status === "aborted", c0 = (Q) => Q.status === "dirty", R0 = (Q) => Q.status === "valid", j0 = (Q) => typeof Promise !== "undefined" && Q instanceof Promise; var _; (function (Q) { Q.errToObj = (W) => typeof W === "string" ? { message: W } : W || {}, Q.toString = (W) => typeof W === "string" ? W : W === null || W === void 0 ? void 0 : W.message })(_ || (_ = {})); var _0, O0; class C { constructor(Q, W, X, G) { this._cachedPath = [], this.parent = Q, this.data = W, this._path = X, this._key = G } get path() { if (!this._cachedPath.length) if (this._key instanceof Array) this._cachedPath.push(...this._path, ...this._key); else this._cachedPath.push(...this._path, this._key); return this._cachedPath } } var r0 = (Q, W) => { if (R0(W)) return { success: !0, data: W.value }; else { if (!Q.common.issues.length) throw new Error("Validation failed but no issues detected."); return { success: !1, get error() { if (this._error) return this._error; const X = new F(Q.common.issues); return this._error = X, this._error } } } }; class S { constructor(Q) { this.spa = this.safeParseAsync, this._def = Q, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this) } get description() { return this._def.description } _getType(Q) { return T(Q.data) } _getOrReturnCtx(Q, W) { return W || { common: Q.parent.common, data: Q.data, parsedType: T(Q.data), schemaErrorMap: this._def.errorMap, path: Q.path, parent: Q.parent } } _processInputParams(Q) { return { status: new D, ctx: { common: Q.parent.common, data: Q.data, parsedType: T(Q.data), schemaErrorMap: this._def.errorMap, path: Q.path, parent: Q.parent } } } _parseSync(Q) { const W = this._parse(Q); if (j0(W)) throw new Error("Synchronous parse encountered promise."); return W } _parseAsync(Q) { const W = this._parse(Q); return Promise.resolve(W) } parse(Q, W) { const X = this.safeParse(Q, W); if (X.success) return X.data; throw X.error } safeParse(Q, W) { var X; const G = { common: { issues: [], async: (X = W === null || W === void 0 ? void 0 : W.async) !== null && X !== void 0 ? X : !1, contextualErrorMap: W === null || W === void 0 ? void 0 : W.errorMap }, path: (W === null || W === void 0 ? void 0 : W.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: Q, parsedType: T(Q) }, J = this._parseSync({ data: Q, path: G.path, parent: G }); return r0(G, J) } async parseAsync(Q, W) { const X = await this.safeParseAsync(Q, W); if (X.success) return X.data; throw X.error } async safeParseAsync(Q, W) { const X = { common: { issues: [], contextualErrorMap: W === null || W === void 0 ? void 0 : W.errorMap, async: !0 }, path: (W === null || W === void 0 ? void 0 : W.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: Q, parsedType: T(Q) }, G = this._parse({ data: Q, path: X.path, parent: X }), J = await (j0(G) ? G : Promise.resolve(G)); return r0(X, J) } refine(Q, W) { const X = (G) => { if (typeof W === "string" || typeof W === "undefined") return { message: W }; else if (typeof W === "function") return W(G); else return W }; return this._refinement((G, J) => { const q = Q(G), Y = () => J.addIssue({ code: H.custom, ...X(G) }); if (typeof Promise !== "undefined" && q instanceof Promise) return q.then((M) => { if (!M) return Y(), !1; else return !0 }); if (!q) return Y(), !1; else return !0 }) } refinement(Q, W) { return this._refinement((X, G) => { if (!Q(X)) return G.addIssue(typeof W === "function" ? W(X, G) : W), !1; else return !0 }) } _refinement(Q) { return new K({ schema: this, typeName: O.ZodEffects, effect: { type: "refinement", refinement: Q } }) } superRefine(Q) { return this._refinement(Q) } optional() { return f.create(this, this._def) } nullable() { return I.create(this, this._def) } nullish() { return this.nullable().optional() } array() { return b.create(this, this._def) } promise() { return n.create(this, this._def) } or(Q) { return X0.create([this, Q], this._def) } and(Q) { return J0.create(this, Q, this._def) } transform(Q) { return new K({ ...V(this._def), schema: this, typeName: O.ZodEffects, effect: { type: "transform", transform: Q } }) } default(Q) { const W = typeof Q === "function" ? Q : () => Q; return new H0({ ...V(this._def), innerType: this, defaultValue: W, typeName: O.ZodDefault }) } brand() { return new C0({ typeName: O.ZodBranded, type: this, ...V(this._def) }) } catch(Q) { const W = typeof Q === "function" ? Q : () => Q; return new M0({ ...V(this._def), innerType: this, catchValue: W, typeName: O.ZodCatch }) } describe(Q) { return new this.constructor({ ...this._def, description: Q }) } pipe(Q) { return D0.create(this, Q) } readonly() { return w0.create(this) } isOptional() { return this.safeParse(void 0).success } isNullable() { return this.safeParse(null).success } } var V2 = /^c[^\s-]{8,}$/i, S2 = /^[0-9a-z]+$/, L2 = /^[0-9A-HJKMNP-TV-Z]{26}$/, A2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, U2 = /^[a-z0-9_-]{21}$/i, D2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, E2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, F2 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", y0, K2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, N2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, b2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, s0 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", f2 = new RegExp(`^${s0}\$`); class N extends S { _parse(Q) { if (this._def.coerce) Q.data = String(Q.data); if (this._getType(Q) !== z.string) { const J = this._getOrReturnCtx(Q); return B(J, { code: H.invalid_type, expected: z.string, received: J.parsedType }), j } const X = new D; let G = void 0; for (let J of this._def.checks) if (J.kind === "min") { if (Q.data.length < J.value) G = this._getOrReturnCtx(Q, G), B(G, { code: H.too_small, minimum: J.value, type: "string", inclusive: !0, exact: !1, message: J.message }), X.dirty() } else if (J.kind === "max") { if (Q.data.length > J.value) G = this._getOrReturnCtx(Q, G), B(G, { code: H.too_big, maximum: J.value, type: "string", inclusive: !0, exact: !1, message: J.message }), X.dirty() } else if (J.kind === "length") { const q = Q.data.length > J.value, Y = Q.data.length < J.value; if (q || Y) { if (G = this._getOrReturnCtx(Q, G), q) B(G, { code: H.too_big, maximum: J.value, type: "string", inclusive: !0, exact: !0, message: J.message }); else if (Y) B(G, { code: H.too_small, minimum: J.value, type: "string", inclusive: !0, exact: !0, message: J.message }); X.dirty() } } else if (J.kind === "email") { if (!E2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "email", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "emoji") { if (!y0) y0 = new RegExp(F2, "u"); if (!y0.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "emoji", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "uuid") { if (!A2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "uuid", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "nanoid") { if (!U2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "nanoid", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "cuid") { if (!V2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "cuid", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "cuid2") { if (!S2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "cuid2", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "ulid") { if (!L2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "ulid", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "url") try { new URL(Q.data) } catch (q) { G = this._getOrReturnCtx(Q, G), B(G, { validation: "url", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "regex") { if (J.regex.lastIndex = 0, !J.regex.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "regex", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "trim") Q.data = Q.data.trim(); else if (J.kind === "includes") { if (!Q.data.includes(J.value, J.position)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: { includes: J.value, position: J.position }, message: J.message }), X.dirty() } else if (J.kind === "toLowerCase") Q.data = Q.data.toLowerCase(); else if (J.kind === "toUpperCase") Q.data = Q.data.toUpperCase(); else if (J.kind === "startsWith") { if (!Q.data.startsWith(J.value)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: { startsWith: J.value }, message: J.message }), X.dirty() } else if (J.kind === "endsWith") { if (!Q.data.endsWith(J.value)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: { endsWith: J.value }, message: J.message }), X.dirty() } else if (J.kind === "datetime") { if (!$2(J).test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: "datetime", message: J.message }), X.dirty() } else if (J.kind === "date") { if (!f2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: "date", message: J.message }), X.dirty() } else if (J.kind === "time") { if (!C2(J).test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { code: H.invalid_string, validation: "time", message: J.message }), X.dirty() } else if (J.kind === "duration") { if (!D2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "duration", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "ip") { if (!v2(Q.data, J.version)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "ip", code: H.invalid_string, message: J.message }), X.dirty() } else if (J.kind === "base64") { if (!b2.test(Q.data)) G = this._getOrReturnCtx(Q, G), B(G, { validation: "base64", code: H.invalid_string, message: J.message }), X.dirty() } else L.assertNever(J); return { status: X.value, value: Q.data } } _regex(Q, W, X) { return this.refinement((G) => Q.test(G), { validation: W, code: H.invalid_string, ..._.errToObj(X) }) } _addCheck(Q) { return new N({ ...this._def, checks: [...this._def.checks, Q] }) } email(Q) { return this._addCheck({ kind: "email", ..._.errToObj(Q) }) } url(Q) { return this._addCheck({ kind: "url", ..._.errToObj(Q) }) } emoji(Q) { return this._addCheck({ kind: "emoji", ..._.errToObj(Q) }) } uuid(Q) { return this._addCheck({ kind: "uuid", ..._.errToObj(Q) }) } nanoid(Q) { return this._addCheck({ kind: "nanoid", ..._.errToObj(Q) }) } cuid(Q) { return this._addCheck({ kind: "cuid", ..._.errToObj(Q) }) } cuid2(Q) { return this._addCheck({ kind: "cuid2", ..._.errToObj(Q) }) } ulid(Q) { return this._addCheck({ kind: "ulid", ..._.errToObj(Q) }) } base64(Q) { return this._addCheck({ kind: "base64", ..._.errToObj(Q) }) } ip(Q) { return this._addCheck({ kind: "ip", ..._.errToObj(Q) }) } datetime(Q) { var W, X; if (typeof Q === "string") return this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: Q }); return this._addCheck({ kind: "datetime", precision: typeof (Q === null || Q === void 0 ? void 0 : Q.precision) === "undefined" ? null : Q === null || Q === void 0 ? void 0 : Q.precision, offset: (W = Q === null || Q === void 0 ? void 0 : Q.offset) !== null && W !== void 0 ? W : !1, local: (X = Q === null || Q === void 0 ? void 0 : Q.local) !== null && X !== void 0 ? X : !1, ..._.errToObj(Q === null || Q === void 0 ? void 0 : Q.message) }) } date(Q) { return this._addCheck({ kind: "date", message: Q }) } time(Q) { if (typeof Q === "string") return this._addCheck({ kind: "time", precision: null, message: Q }); return this._addCheck({ kind: "time", precision: typeof (Q === null || Q === void 0 ? void 0 : Q.precision) === "undefined" ? null : Q === null || Q === void 0 ? void 0 : Q.precision, ..._.errToObj(Q === null || Q === void 0 ? void 0 : Q.message) }) } duration(Q) { return this._addCheck({ kind: "duration", ..._.errToObj(Q) }) } regex(Q, W) { return this._addCheck({ kind: "regex", regex: Q, ..._.errToObj(W) }) } includes(Q, W) { return this._addCheck({ kind: "includes", value: Q, position: W === null || W === void 0 ? void 0 : W.position, ..._.errToObj(W === null || W === void 0 ? void 0 : W.message) }) } startsWith(Q, W) { return this._addCheck({ kind: "startsWith", value: Q, ..._.errToObj(W) }) } endsWith(Q, W) { return this._addCheck({ kind: "endsWith", value: Q, ..._.errToObj(W) }) } min(Q, W) { return this._addCheck({ kind: "min", value: Q, ..._.errToObj(W) }) } max(Q, W) { return this._addCheck({ kind: "max", value: Q, ..._.errToObj(W) }) } length(Q, W) { return this._addCheck({ kind: "length", value: Q, ..._.errToObj(W) }) } nonempty(Q) { return this.min(1, _.errToObj(Q)) } trim() { return new N({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }) } toLowerCase() { return new N({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }) } toUpperCase() { return new N({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] }) } get isDatetime() { return !!this._def.checks.find((Q) => Q.kind === "datetime") } get isDate() { return !!this._def.checks.find((Q) => Q.kind === "date") } get isTime() { return !!this._def.checks.find((Q) => Q.kind === "time") } get isDuration() { return !!this._def.checks.find((Q) => Q.kind === "duration") } get isEmail() { return !!this._def.checks.find((Q) => Q.kind === "email") } get isURL() { return !!this._def.checks.find((Q) => Q.kind === "url") } get isEmoji() { return !!this._def.checks.find((Q) => Q.kind === "emoji") } get isUUID() { return !!this._def.checks.find((Q) => Q.kind === "uuid") } get isNANOID() { return !!this._def.checks.find((Q) => Q.kind === "nanoid") } get isCUID() { return !!this._def.checks.find((Q) => Q.kind === "cuid") } get isCUID2() { return !!this._def.checks.find((Q) => Q.kind === "cuid2") } get isULID() { return !!this._def.checks.find((Q) => Q.kind === "ulid") } get isIP() { return !!this._def.checks.find((Q) => Q.kind === "ip") } get isBase64() { return !!this._def.checks.find((Q) => Q.kind === "base64") } get minLength() { let Q = null; for (let W of this._def.checks) if (W.kind === "min") { if (Q === null || W.value > Q) Q = W.value } return Q } get maxLength() { let Q = null; for (let W of this._def.checks) if (W.kind === "max") { if (Q === null || W.value < Q) Q = W.value } return Q } } N.create = (Q) => { var W; return new N({ checks: [], typeName: O.ZodString, coerce: (W = Q === null || Q === void 0 ? void 0 : Q.coerce) !== null && W !== void 0 ? W : !1, ...V(Q) }) }; class l extends S { constructor() { super(...arguments); this.min = this.gte, this.max = this.lte, this.step = this.multipleOf } _parse(Q) { if (this._def.coerce) Q.data = Number(Q.data); if (this._getType(Q) !== z.number) { const J = this._getOrReturnCtx(Q); return B(J, { code: H.invalid_type, expected: z.number, received: J.parsedType }), j } let X = void 0; const G = new D; for (let J of this._def.checks) if (J.kind === "int") { if (!L.isInteger(Q.data)) X = this._getOrReturnCtx(Q, X), B(X, { code: H.invalid_type, expected: "integer", received: "float", message: J.message }), G.dirty() } else if (J.kind === "min") { if (J.inclusive ? Q.data < J.value : Q.data <= J.value) X = this._getOrReturnCtx(Q, X), B(X, { code: H.too_small, minimum: J.value, type: "number", inclusive: J.inclusive, exact: !1, message: J.message }), G.dirty() } else if (J.kind === "max") { if (J.inclusive ? Q.data > J.value : Q.data >= J.value) X = this._getOrReturnCtx(Q, X), B(X, { code: H.too_big, maximum: J.value, type: "number", inclusive: J.inclusive, exact: !1, message: J.message }), G.dirty() } else if (J.kind === "multipleOf") { if (k2(Q.data, J.value) !== 0) X = this._getOrReturnCtx(Q, X), B(X, { code: H.not_multiple_of, multipleOf: J.value, message: J.message }), G.dirty() } else if (J.kind === "finite") { if (!Number.isFinite(Q.data)) X = this._getOrReturnCtx(Q, X), B(X, { code: H.not_finite, message: J.message }), G.dirty() } else L.assertNever(J); return { status: G.value, value: Q.data } } gte(Q, W) { return this.setLimit("min", Q, !0, _.toString(W)) } gt(Q, W) { return this.setLimit("min", Q, !1, _.toString(W)) } lte(Q, W) { return this.setLimit("max", Q, !0, _.toString(W)) } lt(Q, W) { return this.setLimit("max", Q, !1, _.toString(W)) } setLimit(Q, W, X, G) { return new l({ ...this._def, checks: [...this._def.checks, { kind: Q, value: W, inclusive: X, message: _.toString(G) }] }) } _addCheck(Q) { return new l({ ...this._def, checks: [...this._def.checks, Q] }) } int(Q) { return this._addCheck({ kind: "int", message: _.toString(Q) }) } positive(Q) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: _.toString(Q) }) } negative(Q) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: _.toString(Q) }) } nonpositive(Q) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: _.toString(Q) }) } nonnegative(Q) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: _.toString(Q) }) } multipleOf(Q, W) { return this._addCheck({ kind: "multipleOf", value: Q, message: _.toString(W) }) } finite(Q) { return this._addCheck({ kind: "finite", message: _.toString(Q) }) } safe(Q) { return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: _.toString(Q) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: _.toString(Q) }) } get minValue() { let Q = null; for (let W of this._def.checks) if (W.kind === "min") { if (Q === null || W.value > Q) Q = W.value } return Q } get maxValue() { let Q = null; for (let W of this._def.checks) if (W.kind === "max") { if (Q === null || W.value < Q) Q = W.value } return Q } get isInt() { return !!this._def.checks.find((Q) => Q.kind === "int" || Q.kind === "multipleOf" && L.isInteger(Q.value)) } get isFinite() { let Q = null, W = null; for (let X of this._def.checks) if (X.kind === "finite" || X.kind === "int" || X.kind === "multipleOf") return !0; else if (X.kind === "min") { if (W === null || X.value > W) W = X.value } else if (X.kind === "max") { if (Q === null || X.value < Q) Q = X.value } return Number.isFinite(W) && Number.isFinite(Q) } } l.create = (Q) => { return new l({ checks: [], typeName: O.ZodNumber, coerce: (Q === null || Q === void 0 ? void 0 : Q.coerce) || !1, ...V(Q) }) }; class y extends S { constructor() { super(...arguments); this.min = this.gte, this.max = this.lte } _parse(Q) { if (this._def.coerce) Q.data = BigInt(Q.data); if (this._getType(Q) !== z.bigint) { const J = this._getOrReturnCtx(Q); return B(J, { code: H.invalid_type, expected: z.bigint, received: J.parsedType }), j } let X = void 0; const G = new D; for (let J of this._def.checks) if (J.kind === "min") { if (J.inclusive ? Q.data < J.value : Q.data <= J.value) X = this._getOrReturnCtx(Q, X), B(X, { code: H.too_small, type: "bigint", minimum: J.value, inclusive: J.inclusive, message: J.message }), G.dirty() } else if (J.kind === "max") { if (J.inclusive ? Q.data > J.value : Q.data >= J.value) X = this._getOrReturnCtx(Q, X), B(X, { code: H.too_big, type: "bigint", maximum: J.value, inclusive: J.inclusive, message: J.message }), G.dirty() } else if (J.kind === "multipleOf") { if (Q.data % J.value !== BigInt(0)) X = this._getOrReturnCtx(Q, X), B(X, { code: H.not_multiple_of, multipleOf: J.value, message: J.message }), G.dirty() } else L.assertNever(J); return { status: G.value, value: Q.data } } gte(Q, W) { return this.setLimit("min", Q, !0, _.toString(W)) } gt(Q, W) { return this.setLimit("min", Q, !1, _.toString(W)) } lte(Q, W) { return this.setLimit("max", Q, !0, _.toString(W)) } lt(Q, W) { return this.setLimit("max", Q, !1, _.toString(W)) } setLimit(Q, W, X, G) { return new y({ ...this._def, checks: [...this._def.checks, { kind: Q, value: W, inclusive: X, message: _.toString(G) }] }) } _addCheck(Q) { return new y({ ...this._def, checks: [...this._def.checks, Q] }) } positive(Q) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: _.toString(Q) }) } negative(Q) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: _.toString(Q) }) } nonpositive(Q) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: _.toString(Q) }) } nonnegative(Q) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: _.toString(Q) }) } multipleOf(Q, W) { return this._addCheck({ kind: "multipleOf", value: Q, message: _.toString(W) }) } get minValue() { let Q = null; for (let W of this._def.checks) if (W.kind === "min") { if (Q === null || W.value > Q) Q = W.value } return Q } get maxValue() { let Q = null; for (let W of this._def.checks) if (W.kind === "max") { if (Q === null || W.value < Q) Q = W.value } return Q } } y.create = (Q) => { var W; return new y({ checks: [], typeName: O.ZodBigInt, coerce: (W = Q === null || Q === void 0 ? void 0 : Q.coerce) !== null && W !== void 0 ? W : !1, ...V(Q) }) }; class $0 extends S { _parse(Q) { if (this._def.coerce) Q.data = Boolean(Q.data); if (this._getType(Q) !== z.boolean) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.boolean, received: X.parsedType }), j } return E(Q.data) } } $0.create = (Q) => { return new $0({ typeName: O.ZodBoolean, coerce: (Q === null || Q === void 0 ? void 0 : Q.coerce) || !1, ...V(Q) }) }; class Z extends S { _parse(Q) { if (this._def.coerce) Q.data = new Date(Q.data); if (this._getType(Q) !== z.date) { const J = this._getOrReturnCtx(Q); return B(J, { code: H.invalid_type, expected: z.date, received: J.parsedType }), j } if (isNaN(Q.data.getTime())) { const J = this._getOrReturnCtx(Q); return B(J, { code: H.invalid_date }), j } const X = new D; let G = void 0; for (let J of this._def.checks) if (J.kind === "min") { if (Q.data.getTime() < J.value) G = this._getOrReturnCtx(Q, G), B(G, { code: H.too_small, message: J.message, inclusive: !0, exact: !1, minimum: J.value, type: "date" }), X.dirty() } else if (J.kind === "max") { if (Q.data.getTime() > J.value) G = this._getOrReturnCtx(Q, G), B(G, { code: H.too_big, message: J.message, inclusive: !0, exact: !1, maximum: J.value, type: "date" }), X.dirty() } else L.assertNever(J); return { status: X.value, value: new Date(Q.data.getTime()) } } _addCheck(Q) { return new Z({ ...this._def, checks: [...this._def.checks, Q] }) } min(Q, W) { return this._addCheck({ kind: "min", value: Q.getTime(), message: _.toString(W) }) } max(Q, W) { return this._addCheck({ kind: "max", value: Q.getTime(), message: _.toString(W) }) } get minDate() { let Q = null; for (let W of this._def.checks) if (W.kind === "min") { if (Q === null || W.value > Q) Q = W.value } return Q != null ? new Date(Q) : null } get maxDate() { let Q = null; for (let W of this._def.checks) if (W.kind === "max") { if (Q === null || W.value < Q) Q = W.value } return Q != null ? new Date(Q) : null } } Z.create = (Q) => { return new Z({ checks: [], coerce: (Q === null || Q === void 0 ? void 0 : Q.coerce) || !1, typeName: O.ZodDate, ...V(Q) }) }; class V0 extends S { _parse(Q) { if (this._getType(Q) !== z.symbol) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.symbol, received: X.parsedType }), j } return E(Q.data) } } V0.create = (Q) => { return new V0({ typeName: O.ZodSymbol, ...V(Q) }) }; class Q0 extends S { _parse(Q) { if (this._getType(Q) !== z.undefined) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.undefined, received: X.parsedType }), j } return E(Q.data) } } Q0.create = (Q) => { return new Q0({ typeName: O.ZodUndefined, ...V(Q) }) }; class W0 extends S { _parse(Q) { if (this._getType(Q) !== z.null) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.null, received: X.parsedType }), j } return E(Q.data) } } W0.create = (Q) => { return new W0({ typeName: O.ZodNull, ...V(Q) }) }; class c extends S { constructor() { super(...arguments); this._any = !0 } _parse(Q) { return E(Q.data) } } c.create = (Q) => { return new c({ typeName: O.ZodAny, ...V(Q) }) }; class x extends S { constructor() { super(...arguments); this._unknown = !0 } _parse(Q) { return E(Q.data) } } x.create = (Q) => { return new x({ typeName: O.ZodUnknown, ...V(Q) }) }; class k extends S { _parse(Q) { const W = this._getOrReturnCtx(Q); return B(W, { code: H.invalid_type, expected: z.never, received: W.parsedType }), j } } k.create = (Q) => { return new k({ typeName: O.ZodNever, ...V(Q) }) }; class S0 extends S { _parse(Q) { if (this._getType(Q) !== z.undefined) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.void, received: X.parsedType }), j } return E(Q.data) } } S0.create = (Q) => { return new S0({ typeName: O.ZodVoid, ...V(Q) }) }; class b extends S { _parse(Q) { const { ctx: W, status: X } = this._processInputParams(Q), G = this._def; if (W.parsedType !== z.array) return B(W, { code: H.invalid_type, expected: z.array, received: W.parsedType }), j; if (G.exactLength !== null) { const q = W.data.length > G.exactLength.value, Y = W.data.length < G.exactLength.value; if (q || Y) B(W, { code: q ? H.too_big : H.too_small, minimum: Y ? G.exactLength.value : void 0, maximum: q ? G.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: G.exactLength.message }), X.dirty() } if (G.minLength !== null) { if (W.data.length < G.minLength.value) B(W, { code: H.too_small, minimum: G.minLength.value, type: "array", inclusive: !0, exact: !1, message: G.minLength.message }), X.dirty() } if (G.maxLength !== null) { if (W.data.length > G.maxLength.value) B(W, { code: H.too_big, maximum: G.maxLength.value, type: "array", inclusive: !0, exact: !1, message: G.maxLength.message }), X.dirty() } if (W.common.async) return Promise.all([...W.data].map((q, Y) => { return G.type._parseAsync(new C(W, q, W.path, Y)) })).then((q) => { return D.mergeArray(X, q) }); const J = [...W.data].map((q, Y) => { return G.type._parseSync(new C(W, q, W.path, Y)) }); return D.mergeArray(X, J) } get element() { return this._def.type } min(Q, W) { return new b({ ...this._def, minLength: { value: Q, message: _.toString(W) } }) } max(Q, W) { return new b({ ...this._def, maxLength: { value: Q, message: _.toString(W) } }) } length(Q, W) { return new b({ ...this._def, exactLength: { value: Q, message: _.toString(W) } }) } nonempty(Q) { return this.min(1, Q) } } b.create = (Q, W) => { return new b({ type: Q, minLength: null, maxLength: null, exactLength: null, typeName: O.ZodArray, ...V(W) }) }; class U extends S { constructor() { super(...arguments); this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend } _getCached() { if (this._cached !== null) return this._cached; const Q = this._def.shape(), W = L.objectKeys(Q); return this._cached = { shape: Q, keys: W } } _parse(Q) { if (this._getType(Q) !== z.object) { const w = this._getOrReturnCtx(Q); return B(w, { code: H.invalid_type, expected: z.object, received: w.parsedType }), j } const { status: X, ctx: G } = this._processInputParams(Q), { shape: J, keys: q } = this._getCached(), Y = []; if (!(this._def.catchall instanceof k && this._def.unknownKeys === "strip")) { for (let w in G.data) if (!q.includes(w)) Y.push(w) } const M = []; for (let w of q) { const R = J[w], A = G.data[w]; M.push({ key: { status: "valid", value: w }, value: R._parse(new C(G, A, G.path, w)), alwaysSet: w in G.data }) } if (this._def.catchall instanceof k) { const w = this._def.unknownKeys; if (w === "passthrough") for (let R of Y) M.push({ key: { status: "valid", value: R }, value: { status: "valid", value: G.data[R] } }); else if (w === "strict") { if (Y.length > 0) B(G, { code: H.unrecognized_keys, keys: Y }), X.dirty() } else if (w === "strip"); else throw new Error("Internal ZodObject error: invalid unknownKeys value.") } else { const w = this._def.catchall; for (let R of Y) { const A = G.data[R]; M.push({ key: { status: "valid", value: R }, value: w._parse(new C(G, A, G.path, R)), alwaysSet: R in G.data }) } } if (G.common.async) return Promise.resolve().then(async () => { const w = []; for (let R of M) { const A = await R.key, i0 = await R.value; w.push({ key: A, value: i0, alwaysSet: R.alwaysSet }) } return w }).then((w) => { return D.mergeObjectSync(X, w) }); else return D.mergeObjectSync(X, M) } get shape() { return this._def.shape() } strict(Q) { return _.errToObj, new U({ ...this._def, unknownKeys: "strict", ...Q !== void 0 ? { errorMap: (W, X) => { var G, J, q, Y; const M = (q = (J = (G = this._def).errorMap) === null || J === void 0 ? void 0 : J.call(G, W, X).message) !== null && q !== void 0 ? q : X.defaultError; if (W.code === "unrecognized_keys") return { message: (Y = _.errToObj(Q).message) !== null && Y !== void 0 ? Y : M }; return { message: M } } } : {} }) } strip() { return new U({ ...this._def, unknownKeys: "strip" }) } passthrough() { return new U({ ...this._def, unknownKeys: "passthrough" }) } extend(Q) { return new U({ ...this._def, shape: () => ({ ...this._def.shape(), ...Q }) }) } merge(Q) { return new U({ unknownKeys: Q._def.unknownKeys, catchall: Q._def.catchall, shape: () => ({ ...this._def.shape(), ...Q._def.shape() }), typeName: O.ZodObject }) } setKey(Q, W) { return this.augment({ [Q]: W }) } catchall(Q) { return new U({ ...this._def, catchall: Q }) } pick(Q) { const W = {}; return L.objectKeys(Q).forEach((X) => { if (Q[X] && this.shape[X]) W[X] = this.shape[X] }), new U({ ...this._def, shape: () => W }) } omit(Q) { const W = {}; return L.objectKeys(this.shape).forEach((X) => { if (!Q[X]) W[X] = this.shape[X] }), new U({ ...this._def, shape: () => W }) } deepPartial() { return a(this) } partial(Q) { const W = {}; return L.objectKeys(this.shape).forEach((X) => { const G = this.shape[X]; if (Q && !Q[X]) W[X] = G; else W[X] = G.optional() }), new U({ ...this._def, shape: () => W }) } required(Q) { const W = {}; return L.objectKeys(this.shape).forEach((X) => { if (Q && !Q[X]) W[X] = this.shape[X]; else { let J = this.shape[X]; while (J instanceof f) J = J._def.innerType; W[X] = J } }), new U({ ...this._def, shape: () => W }) } keyof() { return Q2(L.objectKeys(this.shape)) } } U.create = (Q, W) => { return new U({ shape: () => Q, unknownKeys: "strip", catchall: k.create(), typeName: O.ZodObject, ...V(W) }) }; U.strictCreate = (Q, W) => { return new U({ shape: () => Q, unknownKeys: "strict", catchall: k.create(), typeName: O.ZodObject, ...V(W) }) }; U.lazycreate = (Q, W) => { return new U({ shape: Q, unknownKeys: "strip", catchall: k.create(), typeName: O.ZodObject, ...V(W) }) }; class X0 extends S { _parse(Q) { const { ctx: W } = this._processInputParams(Q), X = this._def.options; function G(J) { for (let Y of J) if (Y.result.status === "valid") return Y.result; for (let Y of J) if (Y.result.status === "dirty") return W.common.issues.push(...Y.ctx.common.issues), Y.result; const q = J.map((Y) => new F(Y.ctx.common.issues)); return B(W, { code: H.invalid_union, unionErrors: q }), j } if (W.common.async) return Promise.all(X.map(async (J) => { const q = { ...W, common: { ...W.common, issues: [] }, parent: null }; return { result: await J._parseAsync({ data: W.data, path: W.path, parent: q }), ctx: q } })).then(G); else { let J = void 0; const q = []; for (let M of X) { const w = { ...W, common: { ...W.common, issues: [] }, parent: null }, R = M._parseSync({ data: W.data, path: W.path, parent: w }); if (R.status === "valid") return R; else if (R.status === "dirty" && !J) J = { result: R, ctx: w }; if (w.common.issues.length) q.push(w.common.issues) } if (J) return W.common.issues.push(...J.ctx.common.issues), J.result; const Y = q.map((M) => new F(M)); return B(W, { code: H.invalid_union, unionErrors: Y }), j } } get options() { return this._def.options } } X0.create = (Q, W) => { return new X0({ options: Q, typeName: O.ZodUnion, ...V(W) }) }; var P = (Q) => { if (Q instanceof G0) return P(Q.schema); else if (Q instanceof K) return P(Q.innerType()); else if (Q instanceof q0) return [Q.value]; else if (Q instanceof m) return Q.options; else if (Q instanceof Y0) return L.objectValues(Q.enum); else if (Q instanceof H0) return P(Q._def.innerType); else if (Q instanceof Q0) return [void 0]; else if (Q instanceof W0) return [null]; else if (Q instanceof f) return [void 0, ...P(Q.unwrap())]; else if (Q instanceof I) return [null, ...P(Q.unwrap())]; else if (Q instanceof C0) return P(Q.unwrap()); else if (Q instanceof w0) return P(Q.unwrap()); else if (Q instanceof M0) return P(Q._def.innerType); else return [] }; class f0 extends S { _parse(Q) { const { ctx: W } = this._processInputParams(Q); if (W.parsedType !== z.object) return B(W, { code: H.invalid_type, expected: z.object, received: W.parsedType }), j; const X = this.discriminator, G = W.data[X], J = this.optionsMap.get(G); if (!J) return B(W, { code: H.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [X] }), j; if (W.common.async) return J._parseAsync({ data: W.data, path: W.path, parent: W }); else return J._parseSync({ data: W.data, path: W.path, parent: W }) } get discriminator() { return this._def.discriminator } get options() { return this._def.options } get optionsMap() { return this._def.optionsMap } static create(Q, W, X) { const G = new Map; for (let J of W) { const q = P(J.shape[Q]); if (!q.length) throw new Error(`A discriminator value for key \`${Q}\` could not be extracted from all schema options`); for (let Y of q) { if (G.has(Y)) throw new Error(`Discriminator property ${String(Q)} has duplicate value ${String(Y)}`); G.set(Y, J) } } return new f0({ typeName: O.ZodDiscriminatedUnion, discriminator: Q, options: W, optionsMap: G, ...V(X) }) } } class J0 extends S { _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q), G = (J, q) => { if (Z0(J) || Z0(q)) return j; const Y = u0(J.value, q.value); if (!Y.valid) return B(X, { code: H.invalid_intersection_types }), j; if (c0(J) || c0(q)) W.dirty(); return { status: W.value, value: Y.data } }; if (X.common.async) return Promise.all([this._def.left._parseAsync({ data: X.data, path: X.path, parent: X }), this._def.right._parseAsync({ data: X.data, path: X.path, parent: X })]).then(([J, q]) => G(J, q)); else return G(this._def.left._parseSync({ data: X.data, path: X.path, parent: X }), this._def.right._parseSync({ data: X.data, path: X.path, parent: X })) } } J0.create = (Q, W, X) => { return new J0({ left: Q, right: W, typeName: O.ZodIntersection, ...V(X) }) }; class h extends S { _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q); if (X.parsedType !== z.array) return B(X, { code: H.invalid_type, expected: z.array, received: X.parsedType }), j; if (X.data.length < this._def.items.length) return B(X, { code: H.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), j; if (!this._def.rest && X.data.length > this._def.items.length) B(X, { code: H.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), W.dirty(); const J = [...X.data].map((q, Y) => { const M = this._def.items[Y] || this._def.rest; if (!M) return null; return M._parse(new C(X, q, X.path, Y)) }).filter((q) => !!q); if (X.common.async) return Promise.all(J).then((q) => { return D.mergeArray(W, q) }); else return D.mergeArray(W, J) } get items() { return this._def.items } rest(Q) { return new h({ ...this._def, rest: Q }) } } h.create = (Q, W) => { if (!Array.isArray(Q)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])"); return new h({ items: Q, typeName: O.ZodTuple, rest: null, ...V(W) }) }; class L0 extends S { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q); if (X.parsedType !== z.object) return B(X, { code: H.invalid_type, expected: z.object, received: X.parsedType }), j; const G = [], J = this._def.keyType, q = this._def.valueType; for (let Y in X.data) G.push({ key: J._parse(new C(X, Y, X.path, Y)), value: q._parse(new C(X, X.data[Y], X.path, Y)), alwaysSet: Y in X.data }); if (X.common.async) return D.mergeObjectAsync(W, G); else return D.mergeObjectSync(W, G) } get element() { return this._def.valueType } static create(Q, W, X) { if (W instanceof S) return new L0({ keyType: Q, valueType: W, typeName: O.ZodRecord, ...V(X) }); return new L0({ keyType: N.create(), valueType: Q, typeName: O.ZodRecord, ...V(W) }) } } class A0 extends S { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q); if (X.parsedType !== z.map) return B(X, { code: H.invalid_type, expected: z.map, received: X.parsedType }), j; const G = this._def.keyType, J = this._def.valueType, q = [...X.data.entries()].map(([Y, M], w) => { return { key: G._parse(new C(X, Y, X.path, [w, "key"])), value: J._parse(new C(X, M, X.path, [w, "value"])) } }); if (X.common.async) { const Y = new Map; return Promise.resolve().then(async () => { for (let M of q) { const w = await M.key, R = await M.value; if (w.status === "aborted" || R.status === "aborted") return j; if (w.status === "dirty" || R.status === "dirty") W.dirty(); Y.set(w.value, R.value) } return { status: W.value, value: Y } }) } else { const Y = new Map; for (let M of q) { const { key: w, value: R } = M; if (w.status === "aborted" || R.status === "aborted") return j; if (w.status === "dirty" || R.status === "dirty") W.dirty(); Y.set(w.value, R.value) } return { status: W.value, value: Y } } } } A0.create = (Q, W, X) => { return new A0({ valueType: W, keyType: Q, typeName: O.ZodMap, ...V(X) }) }; class u extends S { _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q); if (X.parsedType !== z.set) return B(X, { code: H.invalid_type, expected: z.set, received: X.parsedType }), j; const G = this._def; if (G.minSize !== null) { if (X.data.size < G.minSize.value) B(X, { code: H.too_small, minimum: G.minSize.value, type: "set", inclusive: !0, exact: !1, message: G.minSize.message }), W.dirty() } if (G.maxSize !== null) { if (X.data.size > G.maxSize.value) B(X, { code: H.too_big, maximum: G.maxSize.value, type: "set", inclusive: !0, exact: !1, message: G.maxSize.message }), W.dirty() } const J = this._def.valueType; function q(M) { const w = new Set; for (let R of M) { if (R.status === "aborted") return j; if (R.status === "dirty") W.dirty(); w.add(R.value) } return { status: W.value, value: w } } const Y = [...X.data.values()].map((M, w) => J._parse(new C(X, M, X.path, w))); if (X.common.async) return Promise.all(Y).then((M) => q(M)); else return q(Y) } min(Q, W) { return new u({ ...this._def, minSize: { value: Q, message: _.toString(W) } }) } max(Q, W) { return new u({ ...this._def, maxSize: { value: Q, message: _.toString(W) } }) } size(Q, W) { return this.min(Q, W).max(Q, W) } nonempty(Q) { return this.min(1, Q) } } u.create = (Q, W) => { return new u({ valueType: Q, minSize: null, maxSize: null, typeName: O.ZodSet, ...V(W) }) }; class s extends S { constructor() { super(...arguments); this.validate = this.implement } _parse(Q) { const { ctx: W } = this._processInputParams(Q); if (W.parsedType !== z.function) return B(W, { code: H.invalid_type, expected: z.function, received: W.parsedType }), j; function X(Y, M) { return N0({ data: Y, path: W.path, errorMaps: [W.common.contextualErrorMap, W.schemaErrorMap, K0(), e].filter((w) => !!w), issueData: { code: H.invalid_arguments, argumentsError: M } }) } function G(Y, M) { return N0({ data: Y, path: W.path, errorMaps: [W.common.contextualErrorMap, W.schemaErrorMap, K0(), e].filter((w) => !!w), issueData: { code: H.invalid_return_type, returnTypeError: M } }) } const J = { errorMap: W.common.contextualErrorMap }, q = W.data; if (this._def.returns instanceof n) { const Y = this; return E(async function (...M) { const w = new F([]), R = await Y._def.args.parseAsync(M, J).catch((k0) => { throw w.addIssue(X(M, k0)), w }), A = await Reflect.apply(q, this, R); return await Y._def.returns._def.type.parseAsync(A, J).catch((k0) => { throw w.addIssue(G(A, k0)), w }) }) } else { const Y = this; return E(function (...M) { const w = Y._def.args.safeParse(M, J); if (!w.success) throw new F([X(M, w.error)]); const R = Reflect.apply(q, this, w.data), A = Y._def.returns.safeParse(R, J); if (!A.success) throw new F([G(R, A.error)]); return A.data }) } } parameters() { return this._def.args } returnType() { return this._def.returns } args(...Q) { return new s({ ...this._def, args: h.create(Q).rest(x.create()) }) } returns(Q) { return new s({ ...this._def, returns: Q }) } implement(Q) { return this.parse(Q) } strictImplement(Q) { return this.parse(Q) } static create(Q, W, X) { return new s({ args: Q ? Q : h.create([]).rest(x.create()), returns: W || x.create(), typeName: O.ZodFunction, ...V(X) }) } } class G0 extends S { get schema() { return this._def.getter() } _parse(Q) { const { ctx: W } = this._processInputParams(Q); return this._def.getter()._parse({ data: W.data, path: W.path, parent: W }) } } G0.create = (Q, W) => { return new G0({ getter: Q, typeName: O.ZodLazy, ...V(W) }) }; class q0 extends S { _parse(Q) { if (Q.data !== this._def.value) { const W = this._getOrReturnCtx(Q); return B(W, { received: W.data, code: H.invalid_literal, expected: this._def.value }), j } return { status: "valid", value: Q.data } } get value() { return this._def.value } } q0.create = (Q, W) => { return new q0({ value: Q, typeName: O.ZodLiteral, ...V(W) }) }; class m extends S { constructor() { super(...arguments); _0.set(this, void 0) } _parse(Q) { if (typeof Q.data !== "string") { const W = this._getOrReturnCtx(Q), X = this._def.values; return B(W, { expected: L.joinValues(X), received: W.parsedType, code: H.invalid_type }), j } if (!b0(this, _0, "f")) t0(this, _0, new Set(this._def.values), "f"); if (!b0(this, _0, "f").has(Q.data)) { const W = this._getOrReturnCtx(Q), X = this._def.values; return B(W, { received: W.data, code: H.invalid_enum_value, options: X }), j } return E(Q.data) } get options() { return this._def.values } get enum() { const Q = {}; for (let W of this._def.values) Q[W] = W; return Q } get Values() { const Q = {}; for (let W of this._def.values) Q[W] = W; return Q } get Enum() { const Q = {}; for (let W of this._def.values) Q[W] = W; return Q } extract(Q, W = this._def) { return m.create(Q, { ...this._def, ...W }) } exclude(Q, W = this._def) { return m.create(this.options.filter((X) => !Q.includes(X)), { ...this._def, ...W }) } } _0 = new WeakMap; m.create = Q2; class Y0 extends S { constructor() { super(...arguments); O0.set(this, void 0) } _parse(Q) { const W = L.getValidEnumValues(this._def.values), X = this._getOrReturnCtx(Q); if (X.parsedType !== z.string && X.parsedType !== z.number) { const G = L.objectValues(W); return B(X, { expected: L.joinValues(G), received: X.parsedType, code: H.invalid_type }), j } if (!b0(this, O0, "f")) t0(this, O0, new Set(L.getValidEnumValues(this._def.values)), "f"); if (!b0(this, O0, "f").has(Q.data)) { const G = L.objectValues(W); return B(X, { received: X.data, code: H.invalid_enum_value, options: G }), j } return E(Q.data) } get enum() { return this._def.values } } O0 = new WeakMap; Y0.create = (Q, W) => { return new Y0({ values: Q, typeName: O.ZodNativeEnum, ...V(W) }) }; class n extends S { unwrap() { return this._def.type } _parse(Q) { const { ctx: W } = this._processInputParams(Q); if (W.parsedType !== z.promise && W.common.async === !1) return B(W, { code: H.invalid_type, expected: z.promise, received: W.parsedType }), j; const X = W.parsedType === z.promise ? W.data : Promise.resolve(W.data); return E(X.then((G) => { return this._def.type.parseAsync(G, { path: W.path, errorMap: W.common.contextualErrorMap }) })) } } n.create = (Q, W) => { return new n({ type: Q, typeName: O.ZodPromise, ...V(W) }) }; class K extends S { innerType() { return this._def.schema } sourceType() { return this._def.schema._def.typeName === O.ZodEffects ? this._def.schema.sourceType() : this._def.schema } _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q), G = this._def.effect || null, J = { addIssue: (q) => { if (B(X, q), q.fatal) W.abort(); else W.dirty() }, get path() { return X.path } }; if (J.addIssue = J.addIssue.bind(J), G.type === "preprocess") { const q = G.transform(X.data, J); if (X.common.async) return Promise.resolve(q).then(async (Y) => { if (W.value === "aborted") return j; const M = await this._def.schema._parseAsync({ data: Y, path: X.path, parent: X }); if (M.status === "aborted") return j; if (M.status === "dirty") return t(M.value); if (W.value === "dirty") return t(M.value); return M }); else { if (W.value === "aborted") return j; const Y = this._def.schema._parseSync({ data: q, path: X.path, parent: X }); if (Y.status === "aborted") return j; if (Y.status === "dirty") return t(Y.value); if (W.value === "dirty") return t(Y.value); return Y } } if (G.type === "refinement") { const q = (Y) => { const M = G.refinement(Y, J); if (X.common.async) return Promise.resolve(M); if (M instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return Y }; if (X.common.async === !1) { const Y = this._def.schema._parseSync({ data: X.data, path: X.path, parent: X }); if (Y.status === "aborted") return j; if (Y.status === "dirty") W.dirty(); return q(Y.value), { status: W.value, value: Y.value } } else return this._def.schema._parseAsync({ data: X.data, path: X.path, parent: X }).then((Y) => { if (Y.status === "aborted") return j; if (Y.status === "dirty") W.dirty(); return q(Y.value).then(() => { return { status: W.value, value: Y.value } }) }) } if (G.type === "transform") if (X.common.async === !1) { const q = this._def.schema._parseSync({ data: X.data, path: X.path, parent: X }); if (!R0(q)) return q; const Y = G.transform(q.value, J); if (Y instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."); return { status: W.value, value: Y } } else return this._def.schema._parseAsync({ data: X.data, path: X.path, parent: X }).then((q) => { if (!R0(q)) return q; return Promise.resolve(G.transform(q.value, J)).then((Y) => ({ status: W.value, value: Y })) }); L.assertNever(G) } } K.create = (Q, W, X) => { return new K({ schema: Q, typeName: O.ZodEffects, effect: W, ...V(X) }) }; K.createWithPreprocess = (Q, W, X) => { return new K({ schema: W, effect: { type: "preprocess", transform: Q }, typeName: O.ZodEffects, ...V(X) }) }; class f extends S { _parse(Q) { if (this._getType(Q) === z.undefined) return E(void 0); return this._def.innerType._parse(Q) } unwrap() { return this._def.innerType } } f.create = (Q, W) => { return new f({ innerType: Q, typeName: O.ZodOptional, ...V(W) }) }; class I extends S { _parse(Q) { if (this._getType(Q) === z.null) return E(null); return this._def.innerType._parse(Q) } unwrap() { return this._def.innerType } } I.create = (Q, W) => { return new I({ innerType: Q, typeName: O.ZodNullable, ...V(W) }) }; class H0 extends S { _parse(Q) { const { ctx: W } = this._processInputParams(Q); let X = W.data; if (W.parsedType === z.undefined) X = this._def.defaultValue(); return this._def.innerType._parse({ data: X, path: W.path, parent: W }) } removeDefault() { return this._def.innerType } } H0.create = (Q, W) => { return new H0({ innerType: Q, typeName: O.ZodDefault, defaultValue: typeof W.default === "function" ? W.default : () => W.default, ...V(W) }) }; class M0 extends S { _parse(Q) { const { ctx: W } = this._processInputParams(Q), X = { ...W, common: { ...W.common, issues: [] } }, G = this._def.innerType._parse({ data: X.data, path: X.path, parent: { ...X } }); if (j0(G)) return G.then((J) => { return { status: "valid", value: J.status === "valid" ? J.value : this._def.catchValue({ get error() { return new F(X.common.issues) }, input: X.data }) } }); else return { status: "valid", value: G.status === "valid" ? G.value : this._def.catchValue({ get error() { return new F(X.common.issues) }, input: X.data }) } } removeCatch() { return this._def.innerType } } M0.create = (Q, W) => { return new M0({ innerType: Q, typeName: O.ZodCatch, catchValue: typeof W.catch === "function" ? W.catch : () => W.catch, ...V(W) }) }; class U0 extends S { _parse(Q) { if (this._getType(Q) !== z.nan) { const X = this._getOrReturnCtx(Q); return B(X, { code: H.invalid_type, expected: z.nan, received: X.parsedType }), j } return { status: "valid", value: Q.data } } } U0.create = (Q) => { return new U0({ typeName: O.ZodNaN, ...V(Q) }) }; var h2 = Symbol("zod_brand"); class C0 extends S { _parse(Q) { const { ctx: W } = this._processInputParams(Q), X = W.data; return this._def.type._parse({ data: X, path: W.path, parent: W }) } unwrap() { return this._def.type } } class D0 extends S { _parse(Q) { const { status: W, ctx: X } = this._processInputParams(Q); if (X.common.async) return (async () => { const J = await this._def.in._parseAsync({ data: X.data, path: X.path, parent: X }); if (J.status === "aborted") return j; if (J.status === "dirty") return W.dirty(), t(J.value); else return this._def.out._parseAsync({ data: J.value, path: X.path, parent: X }) })(); else { const G = this._def.in._parseSync({ data: X.data, path: X.path, parent: X }); if (G.status === "aborted") return j; if (G.status === "dirty") return W.dirty(), { status: "dirty", value: G.value }; else return this._def.out._parseSync({ data: G.value, path: X.path, parent: X }) } } static create(Q, W) { return new D0({ in: Q, out: W, typeName: O.ZodPipeline }) } } class w0 extends S { _parse(Q) { const W = this._def.innerType._parse(Q), X = (G) => { if (R0(G)) G.value = Object.freeze(G.value); return G }; return j0(W) ? W.then((G) => X(G)) : X(W) } unwrap() { return this._def.innerType } } w0.create = (Q, W) => { return new w0({ innerType: Q, typeName: O.ZodReadonly, ...V(W) }) }; var P2 = { object: U.lazycreate }, O; (function (Q) { Q.ZodString = "ZodString", Q.ZodNumber = "ZodNumber", Q.ZodNaN = "ZodNaN", Q.ZodBigInt = "ZodBigInt", Q.ZodBoolean = "ZodBoolean", Q.ZodDate = "ZodDate", Q.ZodSymbol = "ZodSymbol", Q.ZodUndefined = "ZodUndefined", Q.ZodNull = "ZodNull", Q.ZodAny = "ZodAny", Q.ZodUnknown = "ZodUnknown", Q.ZodNever = "ZodNever", Q.ZodVoid = "ZodVoid", Q.ZodArray = "ZodArray", Q.ZodObject = "ZodObject", Q.ZodUnion = "ZodUnion", Q.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", Q.ZodIntersection = "ZodIntersection", Q.ZodTuple = "ZodTuple", Q.ZodRecord = "ZodRecord", Q.ZodMap = "ZodMap", Q.ZodSet = "ZodSet", Q.ZodFunction = "ZodFunction", Q.ZodLazy = "ZodLazy", Q.ZodLiteral = "ZodLiteral", Q.ZodEnum = "ZodEnum", Q.ZodEffects = "ZodEffects", Q.ZodNativeEnum = "ZodNativeEnum", Q.ZodOptional = "ZodOptional", Q.ZodNullable = "ZodNullable", Q.ZodDefault = "ZodDefault", Q.ZodCatch = "ZodCatch", Q.ZodPromise = "ZodPromise", Q.ZodBranded = "ZodBranded", Q.ZodPipeline = "ZodPipeline", Q.ZodReadonly = "ZodReadonly" })(O || (O = {})); var I2 = (Q, W = { message: `Input not instance of ${Q.name}` }) => W2((X) => X instanceof Q, W), X2 = N.create, J2 = l.create, g2 = U0.create, T2 = y.create, G2 = $0.create, x2 = Z.create, l2 = V0.create, y2 = Q0.create, m2 = W0.create, Z2 = c.create, c2 = x.create, u2 = k.create, n2 = S0.create, p2 = b.create, i2 = U.create, d2 = U.strictCreate, r2 = X0.create, o2 = f0.create, a2 = J0.create, t2 = h.create, s2 = L0.create, e2 = A0.create, $1 = u.create, Q1 = s.create, W1 = G0.create, X1 = q0.create, J1 = m.create, G1 = Y0.create, q1 = n.create, o0 = K.create, Y1 = f.create, H1 = I.create, M1 = K.createWithPreprocess, w1 = D0.create, B1 = () => X2().optional(), z1 = () => J2().optional(), _1 = () => G2().optional(), O1 = { string: (Q) => N.create({ ...Q, coerce: !0 }), number: (Q) => l.create({ ...Q, coerce: !0 }), boolean: (Q) => $0.create({ ...Q, coerce: !0 }), bigint: (Q) => y.create({ ...Q, coerce: !0 }), date: (Q) => Z.create({ ...Q, coerce: !0 }) }, R1 = j, g = Object.freeze({ __proto__: null, defaultErrorMap: e, setErrorMap: R2, getErrorMap: K0, makeIssue: N0, EMPTY_PATH: j2, addIssueToContext: B, ParseStatus: D, INVALID: j, DIRTY: t, OK: E, isAborted: Z0, isDirty: c0, isValid: R0, isAsync: j0, get util() { return L }, get objectUtil() { return m0 }, ZodParsedType: z, getParsedType: T, ZodType: S, datetimeRegex: $2, ZodString: N, ZodNumber: l, ZodBigInt: y, ZodBoolean: $0, ZodDate: Z, ZodSymbol: V0, ZodUndefined: Q0, ZodNull: W0, ZodAny: c, ZodUnknown: x, ZodNever: k, ZodVoid: S0, ZodArray: b, ZodObject: U, ZodUnion: X0, ZodDiscriminatedUnion: f0, ZodIntersection: J0, ZodTuple: h, ZodRecord: L0, ZodMap: A0, ZodSet: u, ZodFunction: s, ZodLazy: G0, ZodLiteral: q0, ZodEnum: m, ZodNativeEnum: Y0, ZodPromise: n, ZodEffects: K, ZodTransformer: K, ZodOptional: f, ZodNullable: I, ZodDefault: H0, ZodCatch: M0, ZodNaN: U0, BRAND: h2, ZodBranded: C0, ZodPipeline: D0, ZodReadonly: w0, custom: W2, Schema: S, ZodSchema: S, late: P2, get ZodFirstPartyTypeKind() { return O }, coerce: O1, any: Z2, array: p2, bigint: T2, boolean: G2, date: x2, discriminatedUnion: o2, effect: o0, enum: J1, function: Q1, instanceof: I2, intersection: a2, lazy: W1, literal: X1, map: e2, nan: g2, nativeEnum: G1, never: u2, null: m2, nullable: H1, number: J2, object: i2, oboolean: _1, onumber: z1, optional: Y1, ostring: B1, pipeline: w1, preprocess: M1, promise: q1, record: s2, set: $1, strictObject: d2, string: X2, symbol: l2, transformer: o0, tuple: t2, undefined: y2, union: r2, unknown: c2, void: n2, NEVER: R1, ZodIssueCode: H, quotelessJson: O2, ZodError: F }); function q2(Q) { let W = Q.evtn; if (typeof W == "undefined") return !1; const X = v0.get(W); if (typeof X == "undefined") return !1; try { return X.parse(Q), !0 } catch (G) { return !1 } } var v0 = new Map; v0.set("query", g.object({ evtn: g.string() })); v0.set("query_reply", g.object({ evtn: g.string(), hat: g.string() })); v0.set("change", g.object({ evtn: g.string(), hat: g.string() })); function H2(Q) { if (Q.key == "Escape") { if (n0(), MPP.chat) MPP.chat.blur() } } function M2(Q, W) { if (MPP.chat) MPP.chat.blur(); $(document).on("keydown", H2), $("#modal #modals > *").hide(), $("#modal").fadeIn(250), $(Q).show(), setTimeout(() => { $(Q).find(W).focus() }, 100), Y2 = Q } function n0() { $(document).off("keydown", H2), $("#modal").fadeOut(100), $("#modal #modals > *").hide(), Y2 = null } var Y2; var p0 = function () { MPP.client.sendArray([{ m: "+custom" }]), console.log("%cMPP hats loaded", "color: #8d3f50; font-size: 14pt;"), MPP.client.off("hi", p0) }, w2 = function (Q) { const W = r(Q); $("#hat-selector-preview").attr("src", W.toString()) }; if (!MPP.client.isConnected()) MPP.client.on("hi", p0); else p0(); $("body").append(`<button class="mpp-hats-button top-button" aria-hidden="true">
    <img id="mpp-hats-button-icon" src="https://hats.hri7566.info/api/hat?id=tophat" style="vertical-align: middle;">
    Hats
</button>`); $(".mpp-hats-button").css({ position: "fixed", right: "6px", top: "58px", "z-index": "100" }); $(".mpp-hats-button").on("click", async () => { $("#modal #modals #hats #hat-selector").empty(), M2("#modal #modals #hats"); const Q = await T0(); for (let W of Object.keys(Q)) { const X = Q[W]; $("#modal #modals #hats #hat-selector").append(`<option value="${W}">${X}</option>`) } $(`#modal #modals #hats #hat-selector option[value=${v()}]`).attr("selected", "true"), w2(v()) }); $("#modals").append(`
<div id="hats" class="dialog" style="height: 175px; margin-top: -90px; display: none;">
<h3>MPP Hats</h3>
<hr />
<p>
    <label>Select hat: &nbsp;
        <select id="hat-selector">
            <option value="">None</option>
        </select>
    </label>
    <label>
        <p>Preview: &nbsp;</p>
        <img style="padding-left: 32px;" id="hat-selector-preview" src="" width=32>
    </label>
</p>
<button class="submit">SUBMIT</button>
</div>`); $("#modal #modals #hats button.submit").on("click", () => { let Q = $("#modal #modals #hats #hat-selector").val(); F0(Q), n0() }); $("#modal #modals #hats select#hat-selector").on("change", function (Q) { const W = $("option:selected", this), X = this.value; w2(X) }); var j1 = "hat_"; MPP.client.on("custom", (Q) => { if (typeof Q.data.m == "undefined") return; if (Q.data.evtn = Q.data.m.substring(j1.length).trim(), delete Q.data.m, !q2(Q.data)) return; o.emit(Q.data, Q) }); MPP.client.on("participant added", (Q) => { p(Q._id, { m: "hat_query" }) }); MPP.client.on("participant removed", (Q) => { g0(Q._id) }); MPP.client.on("participant update", (Q) => { const W = z0(Q._id); if (!W) return; E0(Q._id, W) }); MPP.client.on("ch", (Q) => { F0(v()) }); MPP.client.on("c", async (Q) => { if (typeof Q.c !== "object") return; if (!Array.isArray) return; for (let W = 0; W < Q.c.length; W++)try { const X = Q.c[W]; if (X.m == "dm") continue; const G = MPP.client.findParticipantById(X.p.id); if (!G) continue; const J = z0(G._id); if (!J) continue; const q = `<span class="chat-hat" style="content: url(${r(J)});"></span>`, Y = $(`#chat ul li#msg-${X.id}`); $(Y).children(".name").before(q) } catch (X) { console.error(X); continue } }); MPP.client.on("a", (Q) => { try { const W = MPP.client.findParticipantById(Q.p.id); if (!W) return; const X = z0(W._id); if (!X) return; const G = `<span class="chat-hat" style="content: url(${r(X)});"></span>`, J = $(`#chat ul li#msg-${Q.id}`); $(J).children(".name").before(G) } catch (W) { console.error(W) } }); MPP.hats = x0;
